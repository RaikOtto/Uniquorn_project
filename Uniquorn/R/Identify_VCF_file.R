#' identify_VCF_file
#' 
#' Identifies a cancer cell line contained in a VCF file based 
#' on the pattern (start & length) of all contained mutations/variations.
#' 
#' \code{identify_vcf_file} parses the vcf file and predicts 
#' the identity of the sample
#' 
#' @param vcf_files a character vector containing paths to the 
#' input VCF files. This may be one or many VCF files.
#' @param output_dir a character string giving the directory where output
#' is written to. Output file names are autogenerated as name of input files plus 
#' '_uniquorn_ident.tab' suffix. If \code{""}, write to the standard output connection.
#' @param ref_gen a character string specifying the reference genome version.
#'  All training sets are associated with a reference genome version.
#'  Default is \code{"GRCH37"}.
#' @param minimum_matching_mutations numeric; the minimum amount of mutations
#' that has to match between query and training sample for a positive
#' prediction. Default is \code{0}.
#' @param mutational_weight_inclusion_threshold numeric; include only mutations 
#' with a weight of at least x. Range: \code{0.0} to \code{1.0}. \code{1.0} = unique to CL. 
#' \code{0.0} = found in many CL samples. Default is \code{0.5}.
#' @param only_first_candidate logical; if \code{TRUE}, only the CL identifier
#' with highest score is predicted to be present in the sample. Default is
#' \code{FALSE}.
#' @param write_xls logical; if \code{TRUE}, identification results are additionally 
#' created as xls file for easier reading. The default is \code{FALSE}.
#' @param output_bed_file logical; if \code{TRUE}, BED files for IGV 
#' visualization are created for Cancer Cell lines that pass the threshold. 
#' Default is \code{FALSE}.
#' @param manual_identifier_bed_file a character vector of CL 
#' name(s) whose bed files should be created, independently from 
#' them passing the detection threshold. Only with 
#' \code{output_bed_file = TRUE}.
#' @param verbose logical; if \code{TRUE} status messages and additional 
#' informations are printed. Default is \code{FALSE}
#' @param p_value numeric; required p-value for identification. 
#' Default is \code{.05}.
#' @param q_value numeric; required q-value for identification. 
#' Default is \code{.05}.
#' @param confidence_score numeric, threshold above which a positive 
#' prediction occurs. Default is \code{10.0}.
#' @param n_threads numeric; number of threads to be used.
#' @import WriteXLS stats data.table foreach doParallel
#' @usage 
#' identify_vcf_file( 
#'     vcf_file,
#'     output_dir = "",
#'     ref_gen = "GRCH37",
#'     minimum_matching_mutations = 0,
#'     mutational_weight_inclusion_threshold = 0.5,
#'     only_first_candidate = FALSE,
#'     write_xls = FALSE,
#'     output_bed_file = FALSE,
#'     manual_identifier_bed_file = "",
#'     verbose = FALSE,
#'     p_value = .05,
#'     q_value = .05,
#'     confidence_score = 10.0,
#'     n_threads = 1)
#' @examples 
#' HT29_vcf_file = system.file("extdata/HT29.vcf.gz", package="Uniquorn");
#' 
#' identify_vcf_file(HT29_vcf_file, output_dir = "~/")
#' @return R table with a statistic of the identification result
#' @export
identify_vcf_file = function(
    vcf_files,
    output_dir = "",
    ref_gen = "GRCH37",
    minimum_matching_mutations = 0,
    mutational_weight_inclusion_threshold = 0.5,
    only_first_candidate = FALSE,
    write_xls = FALSE,
    output_bed_file = FALSE,
    manual_identifier_bed_file = "",
    verbose = FALSE,
    p_value = .05,
    q_value = .05,
    confidence_score = 10.0,
    n_threads = 1
){
    base::message("Reference genome: ", ref_gen)
    
    sim_list_stats = initiate_db_and_load_data(request_table = "sim_list_stats",
                                               subset = "*", ref_gen = ref_gen)
    sim_list       = initiate_db_and_load_data(request_table = "sim_list",
                                               subset = c("FINGERPRINT", "CL", "Weight"),
                                               ref_gen = ref_gen)
    
    if (!(any(sim_list_stats[, CL %like% "_COSMIC"]) || any(sim_list_stats[, CL %like% "_CCLE"]))){
        if (verbose){
            warning("CCLE & CoSMIC CLP cancer cell line fingerprint NOT ",
                    "found, defaulting to 60 CellMiner cancer cell lines! ",
                    "It is strongly advised to add ~1900 CCLE & CoSMIC CLs. ", 
                    "See readme.")
        }
    }
    
    filtered_res = filter_for_weights( 
        sim_list = sim_list,
        sim_list_stats = sim_list_stats,
        ref_gen = ref_gen,
        mutational_weight_inclusion_threshold = mutational_weight_inclusion_threshold,
        verbose = verbose
    )
    contained_cls_original = sim_list_stats$CL
    sim_list = filtered_res$sim_list
    sim_list_stats = filtered_res$sim_list_stats
    
    dif = length(contained_cls_original) - length(sim_list_stats$CL)
    dif_cls = contained_cls_original[
        which(!(contained_cls_original %in% sim_list_stats$CL))]
    
    if ((dif != 0) & verbose){
        warning(dif, " CLs have no mutations for the chosen weight ",
                "and cannot be identified: ", paste0(c(dif_cls), collapse = ", "),
                " . Probably they are too closely simlar to other training CLs", ".")
    }
    panels = sim_list_stats[, unique(gsub("^.*_", "_" , unique(CL)))]
    
    # Check for existance of specified vcf files, skip if necessary
    if (verbose){
        message("Reading input VCF files.")
    }
    index_vcf = lapply(vcf_files, function(x) check_files(x))
    if (sum(unlist(index_vcf)) < length(vcf_files)){
        warning("Could not find the following VCF file(s), skipping: \n", 
                paste(vcf_files[!unlist(index_vcf)], collapse = "\n"))
    }
    vcf_files = vcf_files[unlist(index_vcf)]
    
    if (n_threads > 1){
        # Register parallel backend and identify vcf files in parallel
        if (verbose){
            message("Identifying VCF files in parallel.")
        }
        doParallel::registerDoParallel(n_threads)
        foreach::foreach(vcf_file = vcf_files) %dopar% {
            
            path_names = init_and_load_identification( 
                verbose = verbose, 
                vcf_file = vcf_file, 
                ref_gen = ref_gen,
                output_dir = output_dir
            )
            
            vcf_file_name   = path_names$vcf_file_name
            output_file     = path_names$output_file
            output_file_xls = path_names$output_file_xls
            vcf_fingerprint = path_names$vcf_fingerprint
            
            ### important mapping function which establishes the similarity
            found_mut_mapping = which(sim_list$Fingerprint %in% vcf_fingerprint)
            
            res_table = calculate_similarity_results(
                sim_list = sim_list,
                sim_list_stats = sim_list_stats,
                found_mut_mapping = found_mut_mapping,
                minimum_matching_mutations = minimum_matching_mutations,
                p_value = p_value,
                q_value = q_value,
                confidence_score = confidence_score,
                vcf_fingerprint,
                panels = panels
            )
            
            if(length(dif_cls > 0)){
                res_table = add_missing_cls(res_table, dif_cls)
            }
            
            ### correction background
            res_table_statistic = res_table[ 
                res_table$Found_muts != res_table$Count_mutations, ]
            # this is done to avoid distortion of the statistic
            # due to benchmarking the DB with its own fingerprints
            
            nr_matching_variants = as.double(res_table_statistic$Found_muts[ 
                as.double(res_table_statistic$Found_muts) > 0])
            
            if (length(nr_matching_variants) == 0){
                penalty = 0
                penalty_mutations = 0
            } else{ 
                mean_match = mean(nr_matching_variants)
                max_match  = max(nr_matching_variants)
                
                penalty = integrate(
                    f = pbeta,
                    0,
                    1,
                    max_match,
                    max_match/ mean_match,
                    stop.on.error = FALSE
                )$value
                
                penalty_mutations = ceiling(mean_match + (max_match * penalty) / 
                                                ( 1 - penalty ))
            }
            
            if ((minimum_matching_mutations == 0) & (penalty != 0.0)){
                res_table$Conf_score_sig = as.character( 
                    (as.integer(res_table$Found_muts) > 
                         as.integer(penalty_mutations)) &
                        as.logical(res_table$Conf_score_sig))
                
                message("Correcting the background due to traces of random, ",
                        "scale-freeness amounts of matches, requiring at least ", 
                        penalty_mutations, " variants to match.")
            }
            
            if (only_first_candidate){
                res_table$Conf_score_sig[seq(2, length(res_table$Conf_score_sig))] = FALSE
            }
            if (verbose){
                message("Storing information in table: ", output_file)
            }
            
            utils::write.table( 
                res_table,
                output_file,
                sep ="\t",
                row.names = FALSE,
                quote = FALSE
            )
            
            if (output_bed_file & (sum(as.logical(res_table$Q_value_sig)) > 0)){
                create_bed_file( 
                    sim_list, 
                    vcf_fingerprint, 
                    res_table, 
                    output_file, 
                    ref_gen, 
                    manual_identifier_bed_file
                )
            }
            
            if (!verbose){
                res_table = res_table[ ,
                                       !(colnames(res_table) %in% c(
                                           "P_values",
                                           "Q_values",
                                           "P_value_sig",
                                           "Q_value_sig"))]
            }
            
            if (write_xls){
                WriteXLS::WriteXLS( 
                    x = res_table, 
                    path.expand(output_file_xls),
                    row.names = FALSE
                )
            }
        }
    } else{
        # Identify vcf files sequentially
        for(vcf_file in vcf_files){
            
            if (verbose){
                message("Identifying VCF file ", vcf_file)
            }
            
            path_names = init_and_load_identification( 
                verbose = verbose, 
                vcf_file = vcf_file, 
                ref_gen = ref_gen,
                output_dir = output_dir
            )
            
            vcf_file_name   = path_names$vcf_file_name
            output_file     = path_names$output_file
            output_file_xls = path_names$output_file_xls
            vcf_fingerprint = path_names$vcf_fingerprint
            
            ### important mapping function which establishes the similarity
            found_mut_mapping = which(sim_list$Fingerprint %in% vcf_fingerprint)
            
            res_table = calculate_similarity_results(
                sim_list = sim_list,
                sim_list_stats = sim_list_stats,
                found_mut_mapping = found_mut_mapping,
                minimum_matching_mutations = minimum_matching_mutations,
                p_value = p_value,
                q_value = q_value,
                confidence_score = confidence_score,
                vcf_fingerprint,
                panels = panels
            )
            
            if(length(dif_cls > 0)){
                res_table = add_missing_cls(res_table, dif_cls)
            }
            
            ### correction background
            res_table_statistic = res_table[ 
                res_table$Found_muts != res_table$Count_mutations, ]
            # this is done to avoid distortion of the statistic
            # due to benchmarking the DB with its own fingerprints
            
            nr_matching_variants = as.double(res_table_statistic$Found_muts[ 
                as.double(res_table_statistic$Found_muts) > 0])
            
            if (length(nr_matching_variants) == 0){
                penalty = 0
                penalty_mutations = 0
            } else{ 
                mean_match = mean(nr_matching_variants)
                max_match  = max(nr_matching_variants)
                
                penalty = integrate(
                    f = pbeta,
                    0,
                    1,
                    max_match,
                    max_match/ mean_match,
                    stop.on.error = FALSE
                )$value
                
                penalty_mutations = ceiling(mean_match + (max_match * penalty) / 
                                                ( 1 - penalty ))
            }
            
            if ((minimum_matching_mutations == 0) & (penalty != 0.0)){
                res_table$Conf_score_sig = as.character( 
                    (as.integer(res_table$Found_muts) > 
                         as.integer(penalty_mutations)) &
                        as.logical(res_table$Conf_score_sig))
                
                message("Correcting the background due to traces of random, ",
                        "scale-freeness amounts of matches, requiring at least ", 
                        penalty_mutations, " variants to match.")
            }
            
            if (only_first_candidate){
                res_table$Conf_score_sig[seq(2, length(res_table$Conf_score_sig))] = FALSE
            }
            if (verbose){
                message("Candidate(s): ", paste0((unique( 
                    as.character(res_table$CL)[res_table$Conf_score_sig == TRUE])), 
                    collapse = ", "))
                message("Storing information in table: ", output_file)
            }
            
            data.table::fwrite( 
                res_table,
                output_file,
                sep ="\t",
                row.names = FALSE,
                quote = FALSE
            )
            
            if (output_bed_file & (sum(as.logical(res_table$Q_value_sig)) > 0)){
                create_bed_file( 
                    sim_list, 
                    vcf_fingerprint, 
                    res_table, 
                    output_file, 
                    ref_gen, 
                    manual_identifier_bed_file
                )
            }
            
            if (!verbose){
                res_table = res_table[ ,
                                       !(colnames(res_table) %in% c(
                                           "P_values",
                                           "Q_values",
                                           "P_value_sig",
                                           "Q_value_sig"))]
            }
            
            if (write_xls){
                WriteXLS::WriteXLS( 
                    x = res_table, 
                    path.expand(output_file_xls),
                    row.names = FALSE
                )
            }
        }
    }
    if (verbose){
        message("Finished identifying VCF files.")
    }
}

