#' identify_VCF_file
#' 
#' Identifies a cancer cell lines contained in a vcf file based 
#' on the pattern (start & length) of all contained mutations/ variations.
#' 
#' \code{identify_vcf_file} parses the vcf file and predicts 
#' the identity of the sample
#' 
#' @param write_xls Create identification results additionally 
#' as xls file for easier reading
#' @param vcf_file Input vcf file. Only one sample column allowed.
#' @param output_file Path of the output file. If blank, 
#' autogenerated as name of input file plus '_uniquorn_ident.tab' suffix.
#' @param ref_gen Reference genome version. All training sets are 
#' associated with a reference genome version. Default: GRCH37
#' @param mutational_weight_inclusion_threshold Include only mutations 
#' with a weight of at least x. Range: 0.0 to 1.0. 1= unique to CL. 
#' ~0 = found in many CL samples. 
#' @param only_first_candidate Only the CL identifier with highest 
#' score is predicted to be present in the sample
#' @param minimum_matching_mutations The minimum amount of mutations that 
#' has to match between query and training sample for a positive prediction
#' @param manual_identifier_bed_file Manually enter a vector of CL 
#' name(s) whose bed files should be created, independently from 
#' them passing the detection threshold
#' @param output_bed_file If BED files for IGV visualization should be 
#' created for the Cancer Cell lines that pass the threshold
#' @param verbose Print additional information
#' @param p_value Required p-value for identification
#' @param q_value Required q-value for identification
#' @param n_threads Number of threads to be used
#' @param confidence_score Threshold above which a positive prediction occurs
#' default 10.0
#' @import WriteXLS stats
#' @usage 
#' identify_vcf_files( 
#' vcf_file,
#' output_file = "",
#' ref_gen = "GRCH37",
#' minimum_matching_mutations = 0,
#' mutational_weight_inclusion_threshold = 0.5,
#' only_first_candidate = FALSE,
#' write_xls = FALSE,
#' output_bed_file = FALSE,
#' manual_identifier_bed_file = "",
#' verbose = FALSE,
#' p_value = .05,
#' q_value = .05,
#' confidence_score = 10.0,
#' n_threads = 1)
#' @examples 
#' HT29_vcf_file = system.file("extdata/HT29.vcf.gz", package="Uniquorn");
#' 
#' identification = identify_vcf_files(HT29_vcf_file)
#' @return R table with a statistic of the identification result
#' @export
identify_vcf_file = function(
    vcf_file,
    output_file = "",
    ref_gen = "GRCH37",
    minimum_matching_mutations = 0,
    mutational_weight_inclusion_threshold = 0.5,
    only_first_candidate = FALSE,
    write_xls = FALSE,
    output_bed_file = FALSE,
    manual_identifier_bed_file = "",
    verbose = FALSE,
    p_value = .05,
    q_value = .05,
    confidence_score = 10.0,
    n_threads = 1
    ){
  
    g_query = parse_vcf_file(vcf_input_file)

    library_path =  paste( c( package_path,"/Libraries_Ref_gen_",ref_gen,"_Uniquorn_DB.RData"), sep ="", collapse= "")
    try( expr = "libraries = readRDS(library_path)")
    
    if (!exists("libraries")){
        stop("No database found")
    }
    
    for( library in libraries ){

        match_query_ccl_to_database_bitwise(
            g_query,
            ref_gen = ref_gen,
            test_mode = test_mode,
            library = library
        )
    }
    
    ### important mapping function which establishes the similarity
    found_mut_mapping = which(sim_list$Fingerprint %in% vcf_fingerprint)
    panels = sim_list_stats[, unique(gsub("^.*_", "_" , unique(CL)))]

    res_table = calculate_similarity_results(
        sim_list = sim_list,
        sim_list_stats = sim_list_stats,
        found_mut_mapping = found_mut_mapping,
        minimum_matching_mutations = minimum_matching_mutations,
        p_value = p_value,
        q_value = q_value,
        confidence_score = confidence_score,
        vcf_fingerprint,
        panels = panels,
        list_of_cls = unique(sim_list_stats$CL)
    )
    
    if(length(dif_cls > 0)){
        res_table = add_missing_cls(res_table, dif_cls)
    }
    
    ### correction background
    
    res_table_statistic = res_table[ 
        res_table$Found_muts != res_table$Count_mutations
    , ]
    # this is done to avoid distortion of the statistic
    # due to benchmarking the DB with its own fingerprints
    
    nr_matching_variants = as.double( res_table_statistic$Found_muts[ 
        as.double( res_table_statistic$Found_muts ) > 0 
    ] )
    
    if ( length(nr_matching_variants) == 0 ){
        
        penalty = 0
        penalty_mutations = 0
        
    } else{ 
        
        mean_match = mean( nr_matching_variants )
        max_match  = max( nr_matching_variants )

        penalty = integrate(
            f = pbeta,
            0,
            1,
            max_match,
            max_match/ mean_match,
            stop.on.error = FALSE
        )$value
        
        penalty_mutations = 
            ceiling(
                mean_match + 
                    ( max_match * penalty ) / 
                    ( 1 - penalty )
            )
    }
    
    
    if ( ( minimum_matching_mutations == 0 ) & ( penalty != 0.0) ){
        
        res_table$Conf_score_sig = as.character( 
            ( as.integer( res_table$Found_muts ) > 
                  as.integer( penalty_mutations ) ) &
            as.logical( res_table$Conf_score_sig )
        )
        
        message( paste0( collapse = "", c( 
            "Correcting the background due to traces of random, scale-freeness amounts of matches, 
            requiring at least ", 
            as.character( penalty_mutations ), " variants to match." ) )
        )
    }
    
    if (only_first_candidate)
        
      res_table$Conf_score_sig[ seq(2, length(res_table$Conf_score_sig)) ] = FALSE
    
    if ( verbose )
        
      print( paste0( "Candidate(s): ", paste0( ( unique( 
            as.character( res_table$CL )[ res_table$Conf_score_sig == TRUE  ]) ), 
            collapse = "," ) )  )
    
    if( verbose )
        
      print( paste0("Storing information in table: ",output_file ) )
    
    utils::write.table( 
        res_table,
        output_file,
        sep ="\t",
        row.names = FALSE,
        quote = FALSE
    )
    
    if (output_bed_file & ( sum( as.logical(res_table$Q_value_sig) ) > 0 ))
         create_bed_file( 
             sim_list, 
             vcf_fingerprint, 
             res_table, 
             output_file, 
             ref_gen, 
             manual_identifier_bed_file
        )
    
    if ( !verbose )
        res_table = res_table[ ,
            !( colnames( res_table ) %in% c(
                "P_values",
                "Q_values",
                "P_value_sig",
                "Q_value_sig"
                )
            )
        ]

    
    if ( write_xls )

        WriteXLS::WriteXLS( 
            x = res_table,
            path.expand(
                output_file_xls
            ),
            row.names = FALSE
        )
    
    return( res_table )
}
