#' identify_VCF_file
#' 
#' Identifies a cancer cell lines contained in a vcf file based 
#' on the pattern (start & length) of all contained mutations/ variations.
#' 
#' \code{identify_vcf_file} parses the vcf file and predicts 
#' the identity of the sample
#' 
#' @param write_xls Create identification results additionally 
#' as xls file for easier reading
#' @param vcf_file Input vcf file. Only one sample column allowed.
#' @param output_file Path of the output file. If blank, 
#' autogenerated as name of input file plus '_uniquorn_ident.tab' suffix.
#' @param ref_gen Reference genome version. All training sets are 
#' associated with a reference genome version. Default: GRCH37
#' @param mutational_weight_inclusion_threshold Include only mutations 
#' with a weight of at least x. Range: 0.0 to 1.0. 1= unique to CL. 
#' ~0 = found in many CL samples. 
#' @param only_first_candidate Only the CL identifier with highest 
#' score is predicted to be present in the sample
#' @param minimum_matching_mutations The minimum amount of mutations that 
#' has to match between query and training sample for a positive prediction
#' @param manual_identifier_bed_file Manually enter a vector of CL 
#' name(s) whose bed files should be created, independently from 
#' them passing the detection threshold
#' @param output_bed_file If BED files for IGV visualization should be 
#' created for the Cancer Cell lines that pass the threshold
#' @param verbose Print additional information
#' @param p_value Required p-value for identification
#' @param q_value Required q-value for identification
#' @param n_threads Number of threads to be used
#' @param confidence_score Threshold above which a positive prediction occurs
#' default 10.0
#' @import WriteXLS stats
#' @usage 
#' identify_vcf_files( 
#' vcf_file,
#' output_file = "",
#' ref_gen = "GRCH37",
#' minimum_matching_mutations = 0,
#' mutational_weight_inclusion_threshold = 0.5,
#' only_first_candidate = FALSE,
#' write_xls = FALSE,
#' output_bed_file = FALSE,
#' manual_identifier_bed_file = "",
#' verbose = FALSE,
#' p_value = .05,
#' q_value = .05,
#' confidence_score = 10.0,
#' n_threads = 1)
#' @examples 
#' HT29_vcf_file = system.file("extdata/HT29.vcf.gz", package="Uniquorn");
#' 
#' identification = identify_vcf_files(HT29_vcf_file)
#' @return R table with a statistic of the identification result
#' @export
identify_vcf_file = function(
    vcf_file,
    output_file = "",
    ref_gen = "GRCH37",
    minimum_matching_mutations = 0,
    mutational_weight_inclusion_threshold = 0.5,
    only_first_candidate = FALSE,
    write_xls = FALSE,
    output_bed_file = FALSE,
    manual_identifier_bed_file = "",
    verbose = FALSE,
    p_value = .05,
    q_value = .05,
    confidence_score = 10.0,
    n_threads = 1
    ){
  
    g_query = parse_vcf_file(vcf_file)
    
    library_names = read_library_names(ref_gen = ref_gen)
    match_t = data.frame(
        CCL = as.character(),
        Matches = as.character(),
        Library = as.character()
    )
    
    for( library_name in library_names ){

        hit_list = match_query_ccl_to_database(
            g_query,
            ref_gen = ref_gen,
            library_name = library_name,
            mutational_weight_inclusion_threshold =
                mutational_weight_inclusion_threshold
        )
        assign("match_t", rbind(match_t,hit_list),envir = .GlobalEnv)
        
        print(paste(c(
            library_name,": ",
            as.character(hit_list$CCL[1]),
            ", matching variants: ",
            as.character(hit_list$Matches[1])),
            sep ="",
            collapse= ""))
    }
    
    # statistics
    
    match_t = add_p_q_values_statistics(match_t)
    match_t = add_penality_statistics(match_t)
    
    if (only_first_candidate)
        
      res_table$Conf_score_sig[ seq(2, length(res_table$Conf_score_sig)) ] = FALSE
    
    if ( verbose )
        
      print( paste0( "Candidate(s): ", paste0( ( unique( 
            as.character( res_table$CL )[ res_table$Conf_score_sig == TRUE  ]) ), 
            collapse = "," ) )  )
    
    if( verbose )
        
      print( paste0("Storing information in table: ",output_file ) )
    
    utils::write.table( 
        res_table,
        output_file,
        sep ="\t",
        row.names = FALSE,
        quote = FALSE
    )
    
    if (output_bed_file & ( sum( as.logical(res_table$Q_value_sig) ) > 0 ))
         create_bed_file( 
             sim_list, 
             vcf_fingerprint, 
             res_table, 
             output_file, 
             ref_gen, 
             manual_identifier_bed_file
        )
    
    if ( !verbose )
        res_table = res_table[ ,
            !( colnames( res_table ) %in% c(
                "P_values",
                "Q_values",
                "P_value_sig",
                "Q_value_sig"
                )
            )
        ]

    
    if ( write_xls )

        WriteXLS::WriteXLS( 
            x = res_table,
            path.expand(
                output_file_xls
            ),
            row.names = FALSE
        )
    
    return( res_table )
}
